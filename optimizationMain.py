"""
optimizationMain.py
======================================
Core module containing data structures, configuration, Theta* pathfinding,
and the main execution script for airpath network optimization (Phase 1.5).

This script performs:
1. Grid creation constrained by a hard road corridor.
2. Integration of tiered No-Fly Zones (NFZ) cost map.
3. Integration of wind data for bi-directional cost calculation.
4. All-pairs pathfinding (hubs).
5. Minimum Spanning Tree (MST) calculation based on cost.
6. Export of results (JSON, PNG).
"""

# ===== Standard & Scientific Libraries =====
import math
import csv
import itertools
import json
import heapq
from dataclasses import dataclass
from enum import Enum
from typing import List, Tuple, Dict, Optional, Any
from datetime import datetime
import glob
import os

import numpy as np
import matplotlib.pyplot as plt
import osmnx as ox
from shapely.geometry import shape, MultiPolygon, Polygon
from shapely import vectorized
import scipy.ndimage # Used for resizing wind grid

# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------

def ts(fmt="%Y%m%d_%H%M%S"):
    """Returns a formatted timestamp string."""
    return datetime.now().strftime(fmt)

def find_latest_wind_file(pattern="wind_grid_*.npz"):
    """Finds the most recent wind data file generated by windOverlay.py."""
    files = glob.glob(pattern)
    if not files:
        return None
    files.sort(key=os.path.getmtime, reverse=True)
    return files[0]

# =============================================================================
# SECTION 1: DATA STRUCTURES AND CONFIGURATION
# =============================================================================

class CellType(Enum):
    """Grid cell classification for visualization and pathfinding."""
    FREE = 0
    NO_FLY = 1
    RESTRICTED = 2
    BUFFER = 3

@dataclass
class Node:
    """Represents a waypoint or hub in the network."""
    id: str
    lat: float
    lon: float
    x: int  # Grid column index
    y: int  # Grid row index
    type: str  # 'hub', 'waypoint'

@dataclass
class Route:
    """Represents a computed drone route."""
    origin: Node
    destination: Node
    path: List[Tuple[int, int]]
    distance: float
    cost: float
    wind_penalty: float # Average headwind component (m/s)

class Config:
    """System configuration parameters and constants."""
    # Singapore approximated boundaries (used for grid bounds)
    LAT_MIN = 1.15
    LAT_MAX = 1.48
    LON_MIN = 103.60
    LON_MAX = 104.42

    # Grid Resolution
    CELL_SIZE = 50  # 50m x 50m cells (Default - Overridden by runner)

    # Pathfinding Cost Weights
    W_DISTANCE = 1.0  # Base cost factor
    W_WIND = 0.3      # Multiplier for headwind/tailwind (m/s)
    W_RISK = 0.5      # Multiplier for (NFZ_cost_multiplier - 1)

    # NFZ Configuration (used by NFZ application helpers)
    NFZ_GEOJSON = "nfz_tiered_approx_v2.geojson"
    ENABLE_NFZ = True

    # NFZ Policy (Strict: Tier1 is a hard block)
    NFZ_POLICY_STRICT = {
        "TIER1_MODE": "hard",
        "TIER1_MULT": 1000.0,
        "TIER2_MULT": 100.0,
        "TIER3_MULT": 10.0,
        "CARVE_T2_T3_ON_ROADS": True,
    }

    # NFZ Policy (Relaxed: Tier1 is a very high cost, not an infinite block)
    NFZ_POLICY_RELAXED = {
        "TIER1_MODE": "soft",
        "TIER1_MULT": 1000.0,
        "TIER2_MULT": 100.0,
        "TIER3_MULT": 10.0,
        "CARVE_T2_T3_ON_ROADS": True,
    }

    # Scenario parameters (set in __main__ block)
    CORRIDOR_RADIUS_M = 120 # Half-width of road corridor
    DRONE_SPEED_MPS = 15.0  # Used for ETA calculation

# =============================================================================
# SECTION 2: SPATIAL GRID AND NFZ/WIND INTEGRATION
# =============================================================================

class SpatialGrid:
    """
    Manages the discrete spatial environment:
    - grid: Stores CellType (e.g., FREE, NO_FLY)
    - cost_map: Stores the pathfinding cost multiplier (rho)
    - wind_field: Stores (u, v) wind vectors
    """
    def __init__(self, rows: int, cols: int, config: Config = Config()):
        self.config = config
        self.rows = rows
        self.cols = cols
        self.cell_m = config.CELL_SIZE
        self.grid = np.full((rows, cols), CellType.FREE.value, dtype=np.uint8)
        
        # Initial cost map: 1.0 everywhere (base distance cost)
        self.cost_map = np.full((rows, cols), 1.0, dtype=np.float32)
        
        # Wind: (rows, cols, 2) array for (u, v) wind vectors. Initialized to zero.
        self.wind_field = np.zeros((rows, cols, 2), dtype=np.float32)
        
        # Internal flag for road corridor mask (used by NFZ carving)
        self._road_mask: Optional[np.ndarray] = None 

    def get_coords(self, lat: float, lon: float) -> Optional[Tuple[int, int]]:
        """Converts (lat, lon) to (y, x) grid coordinates."""
        lat_range = self.config.LAT_MAX - self.config.LAT_MIN
        lon_range = self.config.LON_MAX - self.config.LON_MIN
        
        # Calculate normalized position (0 to 1)
        norm_lat = (lat - self.config.LAT_MIN) / lat_range
        norm_lon = (lon - self.config.LON_MIN) / lon_range
        
        y = int(norm_lat * self.rows)
        x = int(norm_lon * self.cols)
        
        if 0 <= y < self.rows and 0 <= x < self.cols:
            return y, x
        return None

    def _is_valid(self, y: int, x: int) -> bool:
        """Checks if cell is within bounds and not a hard NO_FLY zone (inf cost)."""
        if 0 <= y < self.rows and 0 <= x < self.cols:
            return np.isfinite(self.cost_map[y, x])
        return False
    
    def get_wind_vector(self, y: int, x: int) -> Tuple[float, float]:
        """Returns the (u, v) wind vector at a cell."""
        if 0 <= y < self.rows and 0 <= x < self.cols:
            return float(self.wind_field[y, x, 0]), float(self.wind_field[y, x, 1])
        return 0.0, 0.0

    def add_wind_field(self, wind_data: np.ndarray):
        """
        Stores wind field data (u, v) m/s, resizing if necessary.
        Expects wind_data: (orig_rows, orig_cols, 2) array.
        """
        orig_rows, orig_cols, _ = wind_data.shape
        target_shape = (self.rows, self.cols, 2)
        
        if wind_data.shape[:2] != self.grid.shape:
            # Resize using interpolation (nearest is fastest and usually sufficient)
            print(f"   -> Resizing wind grid from {wind_data.shape[:2]} to {self.grid.shape}...")
            zoom_factor = (self.rows / orig_rows, self.cols / orig_cols, 1)
            # Order 0 for nearest-neighbor, fast, and ensures no smoothing.
            resized_wind = scipy.ndimage.zoom(wind_data, zoom_factor, order=0)
            self.wind_field = resized_wind.astype(np.float32)
        else:
            self.wind_field = wind_data.astype(np.float32)
        print(f"   -> Wind grid applied. Max speed: {np.hypot(self.wind_field[:,:,0], self.wind_field[:,:,1]).max():.2f} m/s")

# --- Grid Builder Helpers ---

def _get_latlon_mesh(grid: SpatialGrid):
    """Generates mesh grids for latitude and longitude cell centers."""
    ys = np.arange(grid.rows); xs = np.arange(grid.cols)
    YY, XX = np.meshgrid(ys, xs, indexing="ij")
    
    lat_range = grid.config.LAT_MAX - grid.config.LAT_MIN
    lon_range = grid.config.LON_MAX - grid.config.LON_MIN

    # Center coordinates of each cell
    lat = grid.config.LAT_MIN + (YY + 0.5)/grid.rows * lat_range
    lon = grid.config.LON_MIN + (XX + 0.5)/grid.cols * lon_range
    return lat, lon

def create_groundbiased_grid_hard_corridor(road_graphml_path: str = "singapore_roads.graphml") -> SpatialGrid:
    """
    Creates a grid where all non-road corridor cells are hard NO_FLY zones.
    The corridor radius is taken from Config.CORRIDOR_RADIUS_M.
    """
    rows = int(round((Config.LAT_MAX - Config.LAT_MIN) * 111000 / Config.CELL_SIZE))
    cols = int(round((Config.LON_MAX - Config.LON_MIN) * 111000 * math.cos(math.radians((Config.LAT_MIN+Config.LAT_MAX)/2)) / Config.CELL_SIZE))
    
    grid = SpatialGrid(rows, cols)

    # 1. Start with entire grid un-constrained (cost=1.0)
    # 2. Load road network
    try:
        G = ox.load_graphml(road_graphml_path)
    except Exception as e:
        print(f"ERROR: Could not load road graphml at {road_graphml_path}. Falling back to downloading (slow).")
        G = ox.graph_from_place("Singapore", network_type="drive", simplify=True)
    
    # 3. Get road geometry
    edges_gdf = ox.graph_to_gdfs(G, nodes=False)
    road_lines = edges_gdf.geometry.unary_union
    
    # 4. Create the buffered road corridor (MultiPolygon)
    corridor = road_lines.buffer(Config.CORRIDOR_RADIUS_M)
    
    # 5. Rasterize the grid and check for corridor overlap
    lat_mesh, lon_mesh = _get_latlon_mesh(grid)
    road_mask = np.zeros((grid.rows, grid.cols), dtype=bool)
    
    # Use vectorized contains for speed
    if isinstance(corridor, MultiPolygon):
        for poly in corridor.geoms:
            road_mask |= vectorized.contains(poly, lon_mesh, lat_mesh)
    elif isinstance(corridor, Polygon):
        road_mask = vectorized.contains(corridor, lon_mesh, lat_mesh)
    
    # 6. Apply the HARD corridor constraint
    # Everything outside the road_mask is NO_FLY (inf cost)
    grid.grid[~road_mask] = CellType.NO_FLY.value
    grid.cost_map[~road_mask] = np.inf
    
    # Store mask for NFZ carving later
    grid._road_mask = road_mask
    
    print(f"   -> Grid (R/C: {rows}x{cols}) created. Corridor FREE cells: {int(road_mask.sum())}")
    return grid

# =============================================================================
# SECTION 3: NFZ Cost Application
# =============================================================================

def _load_tiered_nfz(path: str) -> Dict[str, List[Any]]:
    """Loads NFZ GeoJSON into tiered shapely geometries."""
    with open(path, "r", encoding="utf-8") as f:
        fc = json.load(f)
    buckets = {"Tier1": [], "Tier2": [], "Tier3": []}
    for feat in fc.get("features", []):
        tier = feat.get("properties", {}).get("tier")
        if tier not in buckets:
            continue
        geom = shape(feat.get("geometry"))
        if isinstance(geom, (Polygon, MultiPolygon)):
            buckets[tier].append(geom)
    return buckets

def _apply_nfz_to_grid(grid: SpatialGrid, nfz_buckets: Dict[str, List[Any]], policy: Dict[str, Any]):
    """Mutates grid.cost_map in-place according to NFZ policy."""
    if not nfz_buckets:
        return

    lat_mesh, lon_mesh = _get_latlon_mesh(grid)
    road_mask = grid._road_mask

    def _mask_from_polys(polys: List[Any]) -> np.ndarray:
        """Generates boolean mask for a list of polygons."""
        if not polys:
            return np.zeros((grid.rows, grid.cols), dtype=bool)
        m = np.zeros((grid.rows, grid.cols), dtype=bool)
        for poly in polys:
            try:
                m |= vectorized.contains(poly, lon_mesh, lat_mesh)
            except Exception:
                continue
        return m

    finite_mask = np.isfinite(grid.cost_map) # Only apply to FREE/Corridor cells

    # --- Tier 1 (Highest Priority) ---
    t1_mask = _mask_from_polys(nfz_buckets.get("Tier1", []))
    if policy["TIER1_MODE"] == "hard":
        grid.grid[t1_mask] = CellType.NO_FLY.value
        grid.cost_map[t1_mask] = np.inf
    elif policy["TIER1_MODE"] == "soft":
        mult = float(policy.get("TIER1_MULT", 1000.0))
        grid.cost_map[t1_mask & finite_mask] *= mult

    # --- Tier 2 ---
    t2_mask = _mask_from_polys(nfz_buckets.get("Tier2", []))
    if policy.get("CARVE_T2_T3_ON_ROADS", True) and road_mask is not None:
        t2_mask &= road_mask  # Only penalize T2/T3 inside the road corridor
    mult = float(policy.get("TIER2_MULT", 100.0))
    grid.cost_map[t2_mask & finite_mask] *= mult

    # --- Tier 3 ---
    t3_mask = _mask_from_polys(nfz_buckets.get("Tier3", []))
    if policy.get("CARVE_T2_T3_ON_ROADS", True) and road_mask is not None:
        t3_mask &= road_mask
    mult = float(policy.get("TIER3_MULT", 10.0))
    grid.cost_map[t3_mask & finite_mask] *= mult

# =============================================================================
# SECTION 4: THETA* PATHFINDING AND ROUTE OPTIMIZATION
# =============================================================================

class ThetaStar:
    """
    Implements the Theta* search algorithm for pathfinding on the spatial grid.
    This provides a 'straight-line' heuristic and line-of-sight checks.
    """
    def __init__(self, grid: SpatialGrid):
        self.grid = grid
        # Movement deltas (8 directions)
        self.neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]

    def _get_cost(self, y: int, x: int) -> float:
        """Returns the base cost multiplier (rho) for a cell."""
        if not self.grid._is_valid(y, x):
            return np.inf
        return float(self.grid.cost_map[y, x])

    def _calculate_path_cost(self, p0: Tuple[int, int], p1: Tuple[int, int]) -> float:
        """
        Calculates the total cost for a direct segment p0 -> p1,
        incorporating distance, NFZ risk, and wind penalty.
        """
        cfg = self.grid.config
        y0, x0 = p0; y1, x1 = p1

        # 1. Path metrics (distance and average rho)
        dist_cells = math.hypot(y1 - y0, x1 - x0)
        dist_m = dist_cells * self.grid.cell_m
        
        # Get path points for averaging (Bresenham-like raytrace)
        path_cells = self._raytrace_cells(p0, p1)
        if not path_cells:
             return np.inf

        # Average cost map multiplier (rho) along the path
        y_pts, x_pts = zip(*path_cells)
        rho_path = self.grid.cost_map[y_pts, x_pts]
        rho_avg = np.mean(rho_path)
        
        # If any cell is a hard NO_FLY, the path is blocked.
        if np.isinf(rho_avg):
            return np.inf

        # 2. Wind penalty calculation
        # Vector of path direction (unit vector)
        upath_y = (y1 - y0) / dist_cells if dist_cells else 0
        upath_x = (x1 - x0) / dist_cells if dist_cells else 0

        # Average wind vector along the path
        u_wind_path = self.grid.wind_field[y_pts, x_pts, 0]
        v_wind_path = self.grid.wind_field[y_pts, x_pts, 1]
        w_avg_u, w_avg_v = np.mean(u_wind_path), np.mean(v_wind_path)
        
        # Average headwind component (zeta = -W_avg . U_path)
        # Positive zeta means headwind (cost increase), negative means tailwind (cost decrease)
        zeta_avg = -(w_avg_u * upath_x + w_avg_v * upath_y)

        # 3. Cost components (C = Dist * BaseFactor)
        # Risk cost: Add penalty from NFZ multiplier (> 1.0)
        risk_cost = cfg.W_RISK * max(0, rho_avg - 1.0) 
        
        # Wind cost: Add penalty/benefit from average headwind/tailwind (m/s)
        wind_cost = cfg.W_WIND * zeta_avg
        
        # Total cost factor: Base (1.0) + Risk + Wind
        total_cost_factor = cfg.W_DISTANCE + risk_cost + wind_cost
        
        # CRITICAL: Ensure cost factor is non-negative for the search to work.
        # A strong tailwind might make the factor negative; cap it at a small positive minimum.
        min_factor = 0.1
        if total_cost_factor < min_factor:
            total_cost_factor = min_factor

        return dist_m * total_cost_factor

    def _raytrace_cells(self, p0: Tuple[int, int], p1: Tuple[int, int]) -> List[Tuple[int, int]]:
        """
        Modified Bresenham's line algorithm to collect all traversed cells (y, x).
        """
        y0, x0 = p0; y1, x1 = p1
        pts = []
        dy = abs(y1 - y0); dx = abs(x1 - x0)
        sy = 1 if y0 < y1 else -1
        sx = 1 if x0 < x1 else -1
        err = dx - dy
        y, x = y0, x0
        
        while True:
            pts.append((y, x))
            if y == y1 and x == x1:
                break
            
            e2 = 2 * err
            if e2 > -dy:
                err -= dy
                x += sx
            if e2 < dx:
                err += dx
                y += sy
        return pts

    def _line_of_sight(self, p0: Tuple[int, int], p1: Tuple[int, int]) -> bool:
        """
        Checks if the line segment p0-p1 passes through any hard NO_FLY cells (inf cost).
        """
        path_cells = self._raytrace_cells(p0, p1)
        for y, x in path_cells:
            if not self.grid._is_valid(y, x):
                return False
        return True

    def _h(self, p: Tuple[int, int], goal: Tuple[int, int]) -> float:
        """Heuristic function (straight-line distance in meters)."""
        dy = goal[0] - p[0]
        dx = goal[1] - p[1]
        return math.hypot(dy, dx) * self.grid.cell_m

    def find_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:
        """
        Executes the Theta* search from start to goal (y, x).
        Returns the path as a list of (y, x) tuples, or None if no path is found.
        """
        if not self.grid._is_valid(*start) or not self.grid._is_valid(*goal):
            print("   -> Start or goal node is in a hard NO_FLY zone.")
            return None

        # g_score: Cost from start to node
        g_score = {start: 0.0}
        # came_from: Parent pointer (node -> parent_node)
        came_from = {start: start} 
        # open_set: Priority Queue (f_score, node)
        f_score = {start: self._h(start, goal)}
        open_set = [(f_score[start], start)] 
        
        while open_set:
            current_f, current = heapq.heappop(open_set)

            if current == goal:
                # Reconstruct path
                path = []
                while current != came_from[current]:
                    path.append(current)
                    current = came_from[current]
                path.append(start)
                return path[::-1] # Reverse to start -> goal

            # --- Main Theta* Logic ---
            
            # 1. Neighbor check
            for dy, dx in self.neighbors:
                neighbor = (current[0] + dy, current[1] + dx)
                
                if not self.grid._is_valid(*neighbor):
                    continue

                # Cost from start to neighbor through current (basic A*)
                g_current_to_neighbor = self._calculate_path_cost(current, neighbor)
                g_temp_a_star = g_score[current] + g_current_to_neighbor

                if neighbor not in g_score or g_temp_a_star < g_score[neighbor]:
                    # Standard A* update (if no LOS to parent)
                    parent = current
                    
                    # 2. Line-of-sight check (Theta* extension)
                    if self._line_of_sight(came_from[current], neighbor):
                        # Cost from start to neighbor through parent (LOS)
                        g_parent_to_neighbor = self._calculate_path_cost(came_from[current], neighbor)
                        g_temp_los = g_score[came_from[current]] + g_parent_to_neighbor

                        if g_temp_los < g_temp_a_star:
                            # Prefer the path through the parent
                            g_temp_a_star = g_temp_los
                            parent = came_from[current]

                    if g_temp_a_star < g_score.get(neighbor, np.inf):
                        g_score[neighbor] = g_temp_a_star
                        came_from[neighbor] = parent
                        new_f = g_temp_a_star + self._h(neighbor, goal)
                        f_score[neighbor] = new_f
                        heapq.heappush(open_set, (new_f, neighbor))
        
        return None

class RouteNetworkOptimizer:
    """Manages hub registration and all-pairs routing on the grid."""
    def __init__(self, grid: SpatialGrid):
        self.grid = grid
        self.theta_star = ThetaStar(grid)
        self.hubs: Dict[str, Node] = {}
        self.routes: List[Route] = []

    def register_hub(self, id: str, lat: float, lon: float, type: str = 'hub') -> bool:
        """Registers a hub and converts its coordinates to the grid."""
        coords = self.grid.get_coords(lat, lon)
        if coords is None:
            print(f"⚠️ Hub '{id}' at ({lat:.4f}, {lon:.4f}) is outside grid bounds.")
            return False
        y, x = coords
        if not self.grid._is_valid(y, x):
            print(f"⚠️ Hub '{id}' at ({y},{x}) is in a hard NO_FLY zone (e.g., off-corridor).")
            return False
            
        self.hubs[id] = Node(id, lat, lon, x, y, type)
        return True

    def compute_route(self, origin_id: str, destination_id: str) -> Optional[Route]:
        """Calculates a single route from origin to destination."""
        origin = self.hubs[origin_id]
        dest = self.hubs[destination_id]
        start_pt = (origin.y, origin.x)
        goal_pt = (dest.y, dest.x)

        print(f"  → Routing {origin_id} -> {destination_id}...")
        path = self.theta_star.find_path(start_pt, goal_pt)

        if path is None:
            print(" ❌ No path found.")
            return None

        # Recalculate cost metrics for the final Route object
        distance = self._calculate_distance(path)
        cost = self._calculate_total_cost(path)
        wind_penalty = self._calculate_avg_headwind(path)

        route = Route(
            origin=origin, 
            destination=dest, 
            path=path, 
            distance=distance, 
            cost=cost, 
            wind_penalty=wind_penalty
        )
        self.routes.append(route)
        print(f" ✅ done | {distance/1000:.2f} km | Cost: {cost:.1f} | Avg Headwind: {wind_penalty:.2f} m/s | {len(path)} pts")
        return route

    def compute_all_routes(self) -> Dict[Tuple[str, str], Route]:
        """Computes all bi-directional routes between all unique hub pairs."""
        ids = list(self.hubs.keys())
        routes_map = {}
        
        for a, b in itertools.combinations(ids, 2):
            # A -> B
            r_ab = self.compute_route(a, b)
            if r_ab: routes_map[(a, b)] = r_ab
            
            # B -> A (important for wind asymmetry)
            r_ba = self.compute_route(b, a)
            if r_ba: routes_map[(b, a)] = r_ba
            
        return routes_map

    def _calculate_distance(self, path: List[Tuple[int, int]]) -> float:
        """Calculates path distance in meters by summing segment lengths."""
        dist = 0.0
        cell_m = self.grid.cell_m
        for i in range(len(path) - 1):
            dy = path[i+1][0] - path[i][0]
            dx = path[i+1][1] - path[i][1]
            dist += math.hypot(dy, dx) * cell_m
        return dist

    def _calculate_total_cost(self, path: List[Tuple[int, int]]) -> float:
        """Calculates the final total path cost (C_total)."""
        # Theta* already ensures optimal cost, but we recalculate for simplicity 
        # of the Route object here by summing segment costs.
        total_cost = 0.0
        
        # The true path cost calculation should be re-done segment-by-segment 
        # for a final, accurate total sum of the path segments in the LOS path.
        # However, for brevity and relying on the cost returned by the search,
        # we will use the property that Theta* minimizes this.
        # Since the search doesn't return the *total* cost, but rather the g_score
        # we have to re-evaluate the segments. Let's simplify by running the full 
        # path cost calculation from the ThetaStar logic.
        
        # NOTE: Theta* path points are *only* the vertices.
        # We need to sum the segment costs between these vertices.
        
        for i in range(len(path) - 1):
            p0 = path[i]
            p1 = path[i+1]
            # _calculate_path_cost is the true segment cost function for Theta*
            total_cost += self.theta_star._calculate_path_cost(p0, p1)
            
        return total_cost

    def _calculate_avg_headwind(self, path: List[Tuple[int, int]]) -> float:
        """Calculates the average headwind component (m/s) along the path."""
        # Note: This is an approximation using only the Theta* vertices.
        # The full cost calculation uses all cells in the segment raytrace.
        
        zeta_sum = 0.0
        total_dist_cells = 0.0
        
        for i in range(len(path) - 1):
            y0, x0 = path[i]; y1, x1 = path[i+1]
            dist_cells = math.hypot(y1 - y0, x1 - x0)
            
            if dist_cells > 0:
                # Path segment unit vector
                upath_y = (y1 - y0) / dist_cells
                upath_x = (x1 - x0) / dist_cells
                
                # Wind vector at segment midpoint (approximation)
                mid_y = int((y0 + y1) / 2)
                mid_x = int((x0 + x1) / 2)
                
                u_wind, v_wind = self.grid.get_wind_vector(mid_y, mid_x)
                
                # Headwind component (zeta = -W . U_path)
                zeta = -(u_wind * upath_x + v_wind * upath_y)
                
                zeta_sum += zeta * dist_cells # Weighted average by segment length
                total_dist_cells += dist_cells
                
        return zeta_sum / total_dist_cells if total_dist_cells > 0 else 0.0

    def export_routes(self, filename: str):
        """Exports the computed routes to a GeoJSON-like format."""
        out = []
        for r in self.routes:
            # Convert grid points back to lat/lon for export
            latlon_path = []
            for y, x in r.path:
                norm_lat = (y + 0.5) / self.grid.rows
                norm_lon = (x + 0.5) / self.grid.cols
                lat = self.grid.config.LAT_MIN + norm_lat * (self.grid.config.LAT_MAX - self.grid.config.LAT_MIN)
                lon = self.grid.config.LON_MIN + norm_lon * (self.grid.config.LON_MAX - self.grid.config.LON_MIN)
                latlon_path.append((lon, lat)) # GeoJSON is (lon, lat)

            # Calculate estimated flight time
            if Config.DRONE_SPEED_MPS > 0:
                time_s = r.distance / Config.DRONE_SPEED_MPS
            else:
                time_s = -1.0

            out.append({
                "origin_id": r.origin.id,
                "destination_id": r.destination.id,
                "distance_m": r.distance,
                "total_cost": r.cost,
                "avg_headwind_ms": r.wind_penalty,
                "est_time_s": time_s,
                "waypoints_count": len(r.path),
                "path_lonlat": latlon_path,
            })
            
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(out, f, indent=2)
        print(f"✅ Route data exported to {filename}")

def find_mst_edges(nodes: List[str], dist_lookup: Dict[Tuple[str, str], float]) -> List[Tuple[str, str]]:
    """
    Finds the Minimum Spanning Tree (MST) using Prim's algorithm.
    It uses a lookup of (A, B) or (B, A) costs (distance_m or cost).
    """
    if not nodes: return []
    
    start_node = nodes[0]
    connected = {start_node}
    edges = []
    
    while len(connected) < len(nodes):
        candidate = None
        best_weight = float('inf')
        
        for u in connected:
            for v in nodes:
                if v in connected or u == v:
                    continue
                
                # Check for the minimum cost of the bi-directional pair
                w = min(dist_lookup.get((u, v), float('inf')), 
                        dist_lookup.get((v, u), float('inf')))

                if w == float('inf'):
                    continue # Skip disconnected pairs

                if w < best_weight:
                    best_weight = w
                    candidate = (u, v)

        if candidate is None:
            # Should only happen if the graph is disconnected
            print("⚠️ Graph is disconnected — MST incomplete.")
            break
            
        edges.append(candidate)
        connected.add(candidate[1]) # Add the newly connected node
        
    return edges

# -----------------------------------------------------------------------------
# Visualization Functions
# -----------------------------------------------------------------------------

def plot_optimization_results(optimizer: RouteNetworkOptimizer, routes_all: Dict[Tuple[str, str], Route], cost_lookup: Dict[Tuple[str, str], float], mst_edges: List[Tuple[str, str]], filename: str):
    """Generates the final wind-colored and MST visualization."""
    
    grid = optimizer.grid
    
    # --- 1. Background Grid Plot ---
    fig, ax = plt.subplots(figsize=(12, 12), dpi=150)
    
    # Plot cost map (only finite regions, e.g., the road corridor)
    # Scale cost map for visualization (normalize finite values)
    finite_costs = grid.cost_map[np.isfinite(grid.cost_map)]
    if finite_costs.size > 0:
        norm_costs = np.copy(grid.cost_map)
        norm_costs[np.isinf(norm_costs)] = np.nan
        
        # Log scale for better visualization of multiplier tiers
        log_costs = np.log10(norm_costs)
        
        # Max cost is typically 1000 or more, so log10(1000) = 3
        vmax = np.nanpercentile(log_costs, 99.5) 
        
        ax.imshow(log_costs, origin="lower", cmap="YlOrBr", vmax=vmax, alpha=0.7)
        ax.set_title(f"Optimized Air Network (Wind & NFZ-Cost MST) — Cell Size: {grid.cell_m}m")
    else:
        ax.set_title(f"Optimized Air Network (Wind & NFZ-Cost MST) — No Routes Found")
        
    ax.set_xlabel("Grid X (Col)"); ax.set_ylabel("Grid Y (Row)")
    
    # --- 2. Plot All Bi-Directional Routes (Wind Color) ---
    # Legend: Green (tailwind/low headwind), Yellow (mild), Red (strong headwind)
    for r in routes_all.values():
        yx = np.array(r.path)
        headwind = r.wind_penalty
        
        color = 'g' # green for tailwind or low headwind
        if headwind > 0.5:
            color = 'y' # yellow for mild headwind (> 0.5 m/s)
        if headwind > 1.5:
            color = 'r' # red for strong headwind (> 1.5 m/s)
            
        # Plot thinner lines for all computed paths
        ax.plot(yx[:, 1], yx[:, 0], lw=1.2, alpha=0.7, color=color, zorder=10)

    # --- 3. Plot MST Backbone (Thick Blue Line) ---
    # The MST is the cheapest *bi-directional* connection of the whole graph.
    for u, v in mst_edges:
        # Find the cheaper of the two directions (A->B or B->A)
        cost_ab = cost_lookup.get((u, v), np.inf)
        cost_ba = cost_lookup.get((v, u), np.inf)
        
        r = None
        if cost_ab <= cost_ba and cost_ab != np.inf:
            r = routes_all.get((u, v))
        elif cost_ba < cost_ab and cost_ba != np.inf:
            r = routes_all.get((v, u))
        
        if r:
            yx = np.array(r.path)
            # Plot the path with thick blue line
            ax.plot(yx[:, 1], yx[:, 0], lw=4.0, alpha=0.9, color='blue', zorder=20)

    # --- 4. Plot Hubs ---
    hubs_y = [h.y for h in optimizer.hubs.values()]
    hubs_x = [h.x for h in optimizer.hubs.values()]
    hub_ids = [h.id for h in optimizer.hubs.values()]
    ax.scatter(hubs_x, hubs_y, s=120, c='k', marker='o', edgecolors='w', linewidth=1.5, zorder=30)
    
    for x, y, id in zip(hubs_x, hubs_y, hub_ids):
        ax.text(x, y + 10, id, fontsize=10, ha='center', va='center', weight='bold', color='k', zorder=40)

    ax.set_aspect('equal', adjustable='box')
    plt.tight_layout()
    plt.savefig(filename)
    plt.close(fig)
    print(f"✅ Visualization saved to {filename}")

# =============================================================================
# SECTION 5: SCENARIO RUNNER
# =============================================================================

# Scenario Hubs
HUBS = {
    "Jurong": (1.3336, 103.7438),
    "Woodlands": (1.4380, 103.7860),
    "Sembawang": (1.4503, 103.8188),
    "Punggol": (1.3999, 103.9056),
    "Tampines": (1.3506, 103.9452),
    "Sengkang": (1.3934, 103.8900),
    "Jurong East": (1.3323, 103.7303),
}

def register_hubs(optimizer: RouteNetworkOptimizer, hubs_data: Dict[str, Tuple[float, float]]):
    """Helper to register all scenario hubs."""
    for id, (lat, lon) in hubs_data.items():
        optimizer.register_hub(id, lat, lon)

def main():
    print(f"--- Airpath Optimization Script ({ts(fmt='%H:%M:%S')}) ---")

    # --- Setup Config ---
    # These settings control the core grid and corridor builder
    Config.CELL_SIZE = 40 
    Config.CORRIDOR_RADIUS_M = 120 
    
    # --- Build Grid ---
    print("\n[1/5] Building hard road corridor grid...")
    grid = create_groundbiased_grid_hard_corridor()

    # --- Apply Wind ---
    print("\n[2/5] Applying wind cost layer...")
    latest_wind_file = find_latest_wind_file()
    if latest_wind_file:
        try:
            wind_data = np.load(latest_wind_file)['wind_grid']
            grid.add_wind_field(wind_data)
            print(f"   -> Loaded wind data from {latest_wind_file}")
        except Exception as e:
            print(f"   -> Could not load or apply wind file {latest_wind_file}: {e}")
    else:
        print("   -> No wind file (wind_grid_*.npz) found. Skipping wind cost.")
        
    # --- Apply NFZ ---
    routes_all: Dict[Tuple[str, str], Route] = {}
    
    if Config.ENABLE_NFZ:
        print("\n[3/5] Applying NFZ cost layer (Strict Policy)...")
        nfz_path = Config.NFZ_GEOJSON
        nfz = _load_tiered_nfz(nfz_path)
        _apply_nfz_to_grid(grid, nfz, Config.NFZ_POLICY_STRICT)
    else:
        print("\n[3/5] NFZ layer disabled.")

    # --- Route & Optimization (Strict Pass) ---
    print("\n[4/5] Computing all-pairs routes (A->B & B->A)...")
    optimizer = RouteNetworkOptimizer(grid)
    register_hubs(optimizer, HUBS)
    routes_all = optimizer.compute_all_routes()

    # --- Relaxation Fallback ---
    if not routes_all and Config.ENABLE_NFZ:
        print("\n⚠️ Strict NFZ blocked all routes. Retrying with Tier-1 softened (Relaxed Policy)...")
        # Rebuild fresh grid (roads only), then re-apply relaxed NFZ
        grid = create_groundbiased_grid_hard_corridor() # Re-builds grid
        latest_wind_file = find_latest_wind_file()
        if latest_wind_file: grid.add_wind_field(np.load(latest_wind_file)['wind_grid'])
        
        nfz = _load_tiered_nfz(Config.NFZ_GEOJSON)
        _apply_nfz_to_grid(grid, nfz, Config.NFZ_POLICY_RELAXED)
        
        optimizer = RouteNetworkOptimizer(grid)
        register_hubs(optimizer, HUBS)
        routes_all = optimizer.compute_all_routes()

    if not routes_all:
        raise RuntimeError("No routes found. Check grid settings or hub locations.")

    # --- MST Calculation & Export ---
    print("\n[5/5] Calculating Cost-based MST and exporting results...")
    
    # MST lookup uses the minimum of the bi-directional cost (cost-minimization)
    cost_lookup = {}
    for (a, b) in itertools.combinations(HUBS.keys(), 2):
        r_ab = routes_all.get((a,b)); r_ba = routes_all.get((b,a))
        cost = float('inf')
        if r_ab: cost = r_ab.cost
        if r_ba and r_ba.cost < cost: cost = r_ba.cost
        if cost != float('inf'):
            cost_lookup[(a, b)] = cost # Store only the min cost

    mst_edges = find_mst_edges(list(HUBS.keys()), cost_lookup)

    # Export route data
    optimizer.routes = list(routes_all.values()) # Set all routes for export
    jname = f"phase15_routes_wind_{ts()}.json"
    optimizer.export_routes(jname)

    # Export visualization
    pname = f"phase15_network_wind_{ts()}.png"
    plot_optimization_results(optimizer, routes_all, routes_all, mst_edges, pname)
    
    print("\n--- Optimization Complete ---")

if __name__ == "__main__":
    main()